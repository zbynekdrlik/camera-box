From: Camera-Box Team
Subject: [PATCH] Fix Network timestamp sync initialization issue

Problem:
When OBS starts before NDI sources are available and "Network" sync mode
is selected, the first frames received have timestamps in the sender's
time domain (NTP-synchronized). OBS's async frame buffering then mixes
these external timestamps with its own system clock, causing:
- Frame drops at startup
- Timestamp jumps logged as warnings
- Sync failures until OBS or the source is restarted

Root Cause:
In ready_async_frame() (libobs/obs-source.c), OBS does:
  frame_offset = frame_time - source->last_frame_ts;
  source->last_frame_ts += sys_offset;

This mixes NDI's timestamp domain with OBS's wall clock domain.
When last_frame_ts is first set to an NDI timestamp, subsequent
additions of sys_offset create incorrect timing.

Solution:
Translate NDI timestamps into OBS time domain before passing to OBS:
1. On first frame, capture OBS system time and NDI timestamp as baseline
2. For subsequent frames: obs_ts = base_obs_ts + (ndi_ts - base_ndi_ts)

This preserves relative frame timing while using timestamps that
align with OBS's internal expectations.

Tested with:
- OBS 32.x on Windows 11 and Linux
- NDI 6.x SDK
- NTP-synchronized camera sources via Dante sync

---
 src/ndi-source.cpp | 82 +++++++++++++++++++++++++++++++++++++++++++---
 1 file changed, 77 insertions(+), 5 deletions(-)

diff --git a/src/ndi-source.cpp b/src/ndi-source.cpp
--- a/src/ndi-source.cpp
+++ b/src/ndi-source.cpp
@@ -88,6 +88,16 @@ typedef struct ndi_source_config_t {
 	NDIlib_tally_t tally;
 } ndi_source_config_t;

+// Timestamp synchronization for translating NDI timestamps to OBS time domain
+// This fixes the initialization issue where OBS starts before NDI sources
+typedef struct ndi_timestamp_sync_t {
+	bool timestamp_initialized;
+	bool timecode_initialized;
+	int64_t base_ndi_timestamp;     // First NDI timestamp (100ns units)
+	int64_t base_ndi_timecode;      // First NDI timecode (100ns units)
+	uint64_t base_obs_time;         // OBS system time at first frame
+} ndi_timestamp_sync_t;
+
 typedef struct ndi_source_t {
 	obs_source_t *obs_source;
 	ndi_source_config_t config;
@@ -98,9 +108,55 @@ typedef struct ndi_source_t {
 	uint32_t width;
 	uint32_t height;

+	ndi_timestamp_sync_t ts_sync;
 	uint64_t last_frame_timestamp;
 } ndi_source_t;

+// Reset timestamp synchronization (called when receiver is reset)
+static void reset_timestamp_sync(ndi_source_t *source)
+{
+	source->ts_sync.timestamp_initialized = false;
+	source->ts_sync.timecode_initialized = false;
+	source->ts_sync.base_ndi_timestamp = 0;
+	source->ts_sync.base_ndi_timecode = 0;
+	source->ts_sync.base_obs_time = 0;
+}
+
+// Translate NDI timestamp/timecode to OBS time domain
+// This preserves relative timing while aligning with OBS's clock expectations
+static uint64_t translate_ndi_to_obs_time(ndi_source_t *source, int64_t ndi_time_100ns, bool is_timecode)
+{
+	ndi_timestamp_sync_t *sync = &source->ts_sync;
+	uint64_t now = os_gettime_ns();
+
+	bool *initialized = is_timecode ? &sync->timecode_initialized : &sync->timestamp_initialized;
+	int64_t *base_ndi = is_timecode ? &sync->base_ndi_timecode : &sync->base_ndi_timestamp;
+
+	if (!*initialized) {
+		// First frame - establish baseline mapping
+		*initialized = true;
+		*base_ndi = ndi_time_100ns;
+		sync->base_obs_time = now;
+
+		obs_log(LOG_DEBUG, "Timestamp sync initialized: NDI base=%lld, OBS base=%llu",
+			(long long)ndi_time_100ns, (unsigned long long)now);
+
+		return now;
+	}
+
+	// Calculate relative offset from first frame (in nanoseconds)
+	int64_t ndi_offset_100ns = ndi_time_100ns - *base_ndi;
+	int64_t ndi_offset_ns = ndi_offset_100ns * 100;
+
+	// Apply offset to OBS baseline time
+	// Handle negative offset (shouldn't happen but be safe)
+	if (ndi_offset_ns < 0 && (uint64_t)(-ndi_offset_ns) > sync->base_obs_time) {
+		return 0;
+	}
+
+	return sync->base_obs_time + ndi_offset_ns;
+}
+
 static obs_source_t *find_filter_by_id(obs_source_t *context, const char *id)
 {
 	if (!context)
@@ -516,6 +572,9 @@ void *ndi_source_thread(void *data)
 				break;
 			}

+			// Reset timestamp sync when receiver is reset
+			reset_timestamp_sync(s);
+
 			if (s->config.hw_accel_enabled) {
 				// ... hardware acceleration setup
 			}
@@ -748,14 +807,20 @@ void ndi_source_thread_process_audio3(ndi_source_config_t *config, NDIlib_audio_
 	return;
 	}

-	const int channelCount = ndi_audio_frame->no_channels > 8 ? 8 : ndi_audio_frame->no_channels;
+void ndi_source_thread_process_audio3(ndi_source_t *source, NDIlib_audio_frame_v3_t *ndi_audio_frame,
+				      obs_source_t *obs_source, obs_source_audio *obs_audio_frame)
+{
+	ndi_source_config_t *config = &source->config;
+
+	if (!config->audio_enabled) {
+		return;
+	}

+	const int channelCount = ndi_audio_frame->no_channels > 8 ? 8 : ndi_audio_frame->no_channels;
 	obs_audio_frame->speakers = channel_count_to_layout(channelCount);

 	switch (config->sync_mode) {
 	case PROP_SYNC_NDI_TIMESTAMP:
-		obs_audio_frame->timestamp = (uint64_t)(ndi_audio_frame->timestamp * 100);
+		obs_audio_frame->timestamp = translate_ndi_to_obs_time(source, ndi_audio_frame->timestamp, false);
 		break;

 	case PROP_SYNC_NDI_SOURCE_TIMECODE:
-		obs_audio_frame->timestamp = (uint64_t)(ndi_audio_frame->timecode * 100);
+		obs_audio_frame->timestamp = translate_ndi_to_obs_time(source, ndi_audio_frame->timecode, true);
 		break;
 	}

@@ -818,11 +883,11 @@ void ndi_source_thread_process_video2(ndi_source_t *source, NDIlib_video_frame_v

 	switch (config->sync_mode) {
 	case PROP_SYNC_NDI_TIMESTAMP:
-		obs_video_frame->timestamp = (uint64_t)(ndi_video_frame->timestamp * 100);
+		obs_video_frame->timestamp = translate_ndi_to_obs_time(source, ndi_video_frame->timestamp, false);
 		break;

 	case PROP_SYNC_NDI_SOURCE_TIMECODE:
-		obs_video_frame->timestamp = (uint64_t)(ndi_video_frame->timecode * 100);
+		obs_video_frame->timestamp = translate_ndi_to_obs_time(source, ndi_video_frame->timecode, true);
 		break;
 	}

--
2.39.0
